<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Block Blast ‚Äî Puzzle Game</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-webkit-tap-highlight-color:transparent}
    html,body{height:100%;font-family:Inter,system-ui,Arial;background:#1a1825;color:#fff;overflow:hidden}
    #app{display:flex;flex-direction:column;height:100vh;max-width:500px;margin:0 auto;padding:12px}
    
    header{padding:16px;background:linear-gradient(135deg,#6366f1,#8b5cf6);border-radius:12px;margin-bottom:16px;box-shadow:0 4px 12px rgba(99,102,241,0.3)}
    header h1{font-size:24px;margin-bottom:8px}
    .stats{display:flex;gap:20px;font-size:14px;opacity:0.95}
    .stat{display:flex;align-items:center;gap:6px}
    .stat strong{font-size:20px;color:#fbbf24}
    
    #gameArea{flex:1;display:flex;flex-direction:column;gap:16px;overflow:auto}
    
    #gridWrap{background:#2d2a3e;padding:16px;border-radius:12px;box-shadow:0 4px 16px rgba(0,0,0,0.3)}
    #grid{display:grid;grid-template-columns:repeat(8,1fr);gap:3px;width:100%;max-width:360px;margin:0 auto;aspect-ratio:1}
    .cell{background:#3a3650;border-radius:4px;position:relative;transition:background 0.08s ease,box-shadow 0.08s ease}
    .cell.filled{background:linear-gradient(135deg,#8b5cf6,#6366f1);box-shadow:0 2px 8px rgba(139,92,246,0.4);transition:all 0.3s ease}
    .cell.preview{background:rgba(34,197,94,0.4)!important;box-shadow:0 0 12px rgba(34,197,94,0.3);outline:2px solid #22c55e;outline-offset:-2px}
    .cell.preview-center{background:rgba(34,197,94,0.6)!important;box-shadow:0 0 16px rgba(34,197,94,0.5);outline:3px solid #22c55e;outline-offset:-3px}
    .cell.invalid{background:rgba(239,68,68,0.4)!important;box-shadow:0 0 12px rgba(239,68,68,0.3)!important;outline:2px solid #ef4444!important;outline-offset:-2px}
    
    @keyframes clearPulse{
      0%{transform:scale(1);opacity:1;filter:brightness(1)}
      20%{transform:scale(1.4);opacity:1;filter:brightness(2)}
      40%{transform:scale(1.5) rotate(5deg);opacity:0.9;box-shadow:0 0 40px rgba(251,191,36,1),0 0 80px rgba(251,191,36,0.6)}
      70%{transform:scale(0.8) rotate(-5deg);opacity:0.5}
      100%{transform:scale(0.1);opacity:0}
    }
    .cell.clearing{animation:clearPulse 0.35s cubic-bezier(0.68,-0.55,0.265,1.55);background:linear-gradient(135deg,#fbbf24,#f59e0b,#fbbf24)!important;filter:brightness(1.5)}
    
    @keyframes previewPulse{
      0%{transform:scale(1);box-shadow:0 0 12px rgba(34,197,94,0.3)}
      50%{transform:scale(1.08);box-shadow:0 0 20px rgba(34,197,94,0.6)}
      100%{transform:scale(1);box-shadow:0 0 12px rgba(34,197,94,0.3)}
    }
    .cell.preview{animation:previewPulse 0.8s ease-in-out infinite;animation-delay:0s}
    .cell.preview-center{animation:previewPulse 0.8s ease-in-out infinite;animation-delay:0s}
    
    @keyframes invalidShake{
      0%,100%{transform:translateX(0) scale(1)}
      10%{transform:translateX(-2px) scale(1.02)}
      20%{transform:translateX(2px) scale(1.02)}
      30%{transform:translateX(-2px) scale(1.02)}
      40%{transform:translateX(2px) scale(1.02)}
      50%{transform:translateX(0) scale(1)}
    }
    .cell.invalid{animation:invalidShake 1s ease-in-out infinite}
    
    @keyframes comboShake{
      0%,100%{transform:translate(-50%,-50%) scale(1) rotate(0deg)}
      10%{transform:translate(-50%,-50%) scale(1.3) rotate(-5deg)}
      30%{transform:translate(-50%,-50%) scale(1.2) rotate(5deg)}
      50%{transform:translate(-50%,-50%) scale(1.25) rotate(-3deg)}
      70%{transform:translate(-50%,-50%) scale(1.15) rotate(3deg)}
    }
    
    @keyframes comboFadeOut{
      0%{opacity:1;transform:translate(-50%,-50%) scale(1)}
      100%{opacity:0;transform:translate(-50%,-50%) scale(2) translateY(-50px)}
    }
    
    .combo-indicator{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);font-size:72px;font-weight:900;color:#fbbf24;text-shadow:0 0 20px rgba(251,191,36,1),0 0 40px rgba(251,191,36,0.8),0 0 60px rgba(251,191,36,0.6),0 4px 8px rgba(0,0,0,0.5);pointer-events:none;opacity:0;z-index:1001;filter:drop-shadow(0 0 10px #fbbf24)}
    .combo-indicator.show{animation:comboShake 0.5s cubic-bezier(0.68,-0.55,0.265,1.55),comboFadeOut 1s ease-out 0.3s forwards}
    
    @keyframes pieceAppear{
      0%{opacity:0;transform:translateY(40px) scale(0.5) rotate(-10deg)}
      60%{transform:translateY(-8px) scale(1.1) rotate(3deg)}
      80%{transform:translateY(2px) scale(0.95) rotate(-1deg)}
      100%{opacity:1;transform:translateY(0) scale(1) rotate(0)}
    }
    
    @keyframes piecePlaced{
      0%{transform:scale(1);opacity:1;filter:brightness(1)}
      30%{transform:scale(1.2);opacity:0.9;filter:brightness(1.5)}
      100%{transform:scale(0.7);opacity:0;filter:brightness(2)}
    }
    
    #piecesWrap{background:#2d2a3e;padding:16px;border-radius:12px;box-shadow:0 4px 16px rgba(0,0,0,0.3);min-height:120px}
    #pieces{display:grid;grid-template-columns:repeat(3, 1fr);gap:16px;justify-items:center;align-items:center}
    .piece-slot{min-width:100px;min-height:100px;display:flex;justify-content:center;align-items:center}
    .piece{cursor:grab;padding:8px;background:#3a3650;border-radius:8px;transition:transform 0.3s cubic-bezier(0.68,-0.55,0.265,1.55),box-shadow 0.2s,opacity 0.3s ease;touch-action:none;opacity:0;animation:pieceAppear 0.4s cubic-bezier(0.68,-0.55,0.265,1.55) forwards}
    .piece:nth-child(1){animation-delay:0.05s}
    .piece:nth-child(2){animation-delay:0.15s}
    .piece:nth-child(3){animation-delay:0.25s}
    .piece:active{cursor:grabbing}
    .piece.dragging{transform:scale(1.15);box-shadow:0 12px 32px rgba(139,92,246,0.6),0 0 20px rgba(139,92,246,0.4);z-index:1000;background:rgba(58,54,80,0.6);opacity:0.7;filter:brightness(1.2)}
    .piece.disabled{opacity:0.4;cursor:not-allowed;pointer-events:none}
    .pieceGrid{display:grid;gap:2px;transition:gap 0.15s}
    .piece.dragging .pieceGrid{gap:3px}
    .pieceCell{width:28px;height:28px;background:#8b5cf6;border-radius:3px;box-shadow:0 1px 3px rgba(0,0,0,0.3);transition:all 0.15s}
    .piece.dragging .pieceCell{width:32px;height:32px;border-radius:4px;box-shadow:0 2px 6px rgba(139,92,246,0.4);background:rgba(139,92,246,0.85)}
    
    #gameOver{position:fixed;inset:0;background:rgba(0,0,0,0.85);display:none;align-items:center;justify-content:center;z-index:999}
    #gameOver.show{display:flex}
    .modal{background:#2d2a3e;padding:32px;border-radius:16px;text-align:center;box-shadow:0 8px 32px rgba(0,0,0,0.5);max-width:320px}
    .modal h2{font-size:32px;margin-bottom:16px;color:#fbbf24}
    .modal p{font-size:18px;margin-bottom:24px;color:#d1d5db}
    .btn{background:linear-gradient(135deg,#6366f1,#8b5cf6);border:none;padding:14px 28px;border-radius:8px;color:#fff;font-size:16px;font-weight:600;cursor:pointer;transition:transform 0.2s,box-shadow 0.2s}
    .btn:hover{transform:translateY(-2px);box-shadow:0 6px 16px rgba(99,102,241,0.4)}
    .btn:active{transform:scale(0.98)}
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>üéØ Block Blast</h1>
      <div class="stats">
        <div class="stat">–°—á—ë—Ç: <strong id="score">0</strong></div>
        <div class="stat">–õ—É—á—à–∏–π: <strong id="best">0</strong></div>
        <div class="stat">–ö–æ–º–±–æ: <strong id="combo">0</strong></div>
      </div>
    </header>
    
    <div id="gameArea">
      <div id="gridWrap">
        <div id="grid"></div>
      </div>
      
      <div id="piecesWrap">
        <div id="pieces"></div>
      </div>
    </div>
  </div>
  
  <div id="gameOver">
    <div class="modal">
      <h2>–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! üéÆ</h2>
      <p>–í–∞—à —Å—á—ë—Ç: <strong id="finalScore">0</strong></p>
      <p>–õ—É—á—à–∏–π: <strong id="finalBest">0</strong></p>
      <button class="btn" id="restart">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
    </div>
  </div>
  
  <div class="combo-indicator" id="comboIndicator"></div>

  <script>
  // Block Blast game prototype ‚Äî drag & drop grid puzzle
  const GRID_SIZE = 8;
  const grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(0));
  
  let score = 0;
  let best = parseInt(localStorage.getItem('bb_best') || '0', 10);
  let combo = 0;
  let lastCleared = 0; // Last number of lines cleared (for display)
  let activePieces = [];
  let draggedPiece = null;
  let draggedElement = null;
  
  // Piece library (tetris-like shapes)
  const PIECES = [
    {id:1, shape:[[1]]}, // 1√ó1 square
    {id:2, shape:[[1,1]]}, // 1√ó2 horizontal
    {id:3, shape:[[1],[1]]}, // 2√ó1 vertical
    {id:4, shape:[[1,1],[1,1]]}, // 2√ó2 square
    {id:5, shape:[[1,1,1]]}, // 1√ó3 line
    {id:6, shape:[[1],[1],[1]]}, // 3√ó1 line
    {id:7, shape:[[1,1,1],[1,0,0]]}, // L-shape
    {id:8, shape:[[1,0],[1,0],[1,1]]}, // L-shape rotated
    {id:9, shape:[[1,1,1],[0,0,1]]}, // L-shape mirrored
    {id:10, shape:[[0,1],[0,1],[1,1]]}, // L-shape mirrored rotated
    {id:11, shape:[[1,1,0],[0,1,1]]}, // Z-shape
    {id:12, shape:[[0,1],[1,1],[1,0]]}, // Z-shape rotated
    {id:13, shape:[[0,1,1],[1,1,0]]}, // S-shape
    {id:14, shape:[[1,0],[1,1],[0,1]]}, // S-shape rotated
    {id:15, shape:[[1,1,1],[0,1,0]]}, // T-shape
    {id:16, shape:[[0,1],[1,1],[0,1]]}, // T-shape rotated
  ];
  
  // Initialize grid UI
  const gridEl = document.getElementById('grid');
  for(let r = 0; r < GRID_SIZE; r++){
    for(let c = 0; c < GRID_SIZE; c++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.row = r;
      cell.dataset.col = c;
      gridEl.appendChild(cell);
    }
  }
  
  // Update UI from grid state
  function renderGrid(){
    const cells = gridEl.querySelectorAll('.cell');
    cells.forEach(cell => {
      const r = parseInt(cell.dataset.row);
      const c = parseInt(cell.dataset.col);
      cell.classList.toggle('filled', grid[r][c] === 1);
      // Don't remove clearing class - it will be removed after animation
      cell.classList.remove('preview', 'preview-center', 'invalid');
    });
  }
  
  // Generate random pieces
  function spawnPieces(){
    activePieces = [];
    for(let i = 0; i < 3; i++){
      const piece = PIECES[Math.floor(Math.random() * PIECES.length)];
      activePieces.push({...piece, used: false});
    }
    renderPieces();
    
    // Check if any of the new pieces can be placed
    checkGameOver();
  }
  
  // Render only new pieces (add them smoothly)
  function addNewPieces(){
    const piecesEl = document.getElementById('pieces');
    
    // Clear old pieces first
    piecesEl.innerHTML = '';
    
    // Generate 3 new pieces
    activePieces = [];
    for(let i = 0; i < 3; i++){
      const piece = PIECES[Math.floor(Math.random() * PIECES.length)];
      activePieces.push({...piece, used: false});
    }
    
    // Add them with animation
    renderPieces();
    checkGameOver();
  }
  
  // Render pieces UI
  function renderPieces(){
    const piecesEl = document.getElementById('pieces');
    piecesEl.innerHTML = '';
    activePieces.forEach((piece, idx) => {
      // Create slot container for each piece position
      const slot = document.createElement('div');
      slot.className = 'piece-slot';
      
      if(!piece.used) {
        const pieceEl = document.createElement('div');
        pieceEl.className = 'piece';
        pieceEl.dataset.idx = idx;
        
        const grid = document.createElement('div');
        grid.className = 'pieceGrid';
        grid.style.gridTemplateColumns = `repeat(${piece.shape[0].length}, 28px)`;
        
        piece.shape.forEach(row => {
          row.forEach(val => {
            const cell = document.createElement('div');
            if(val === 1){
              cell.className = 'pieceCell';
            } else {
              cell.style.width = '28px';
              cell.style.height = '28px';
            }
            grid.appendChild(cell);
          });
        });
        
        pieceEl.appendChild(grid);
        slot.appendChild(pieceEl);
        
        // Touch & mouse drag events
        pieceEl.addEventListener('pointerdown', startDrag);
      }
      
      piecesEl.appendChild(slot);
    });
  }
  
  // Check if piece can be placed at (r, c)
  function canPlace(piece, row, col){
    for(let r = 0; r < piece.shape.length; r++){
      for(let c = 0; c < piece.shape[r].length; c++){
        if(piece.shape[r][c] === 1){
          const gr = row + r;
          const gc = col + c;
          if(gr < 0 || gr >= GRID_SIZE || gc < 0 || gc >= GRID_SIZE) return false;
          if(grid[gr][gc] === 1) return false;
        }
      }
    }
    return true;
  }
  
  // Place piece on grid
  function placePiece(piece, row, col){
    for(let r = 0; r < piece.shape.length; r++){
      for(let c = 0; c < piece.shape[r].length; c++){
        if(piece.shape[r][c] === 1){
          grid[row + r][col + c] = 1;
        }
      }
    }
  }
  
  // Clear filled rows and columns with animation
  function clearLines(){
    let clearedCells = [];
    let linesCleared = 0; // Count actual lines (rows + cols)
    
    // Check rows
    for(let r = 0; r < GRID_SIZE; r++){
      if(grid[r].every(v => v === 1)){
        linesCleared++;
        for(let c = 0; c < GRID_SIZE; c++){
          clearedCells.push({r, c});
        }
      }
    }
    
    // Check columns
    for(let c = 0; c < GRID_SIZE; c++){
      if(grid.every(row => row[c] === 1)){
        linesCleared++;
        for(let r = 0; r < GRID_SIZE; r++){
          // Avoid duplicates from row+col intersection
          if(!clearedCells.find(cell => cell.r === r && cell.c === c)){
            clearedCells.push({r, c});
          }
        }
      }
    }
    
    if(clearedCells.length > 0){
      // Vibration feedback
      if(navigator.vibrate){
        navigator.vibrate(clearedCells.length > 8 ? [50, 30, 50] : 50);
      }
      
      // Force reflow to restart animation
      gridEl.offsetHeight;
      
      // Animate clearing - add class with a small delay to ensure it triggers
      requestAnimationFrame(() => {
        clearedCells.forEach(({r, c}) => {
          const cell = gridEl.querySelector(`[data-row="${r}"][data-col="${c}"]`);
          if(cell){
            cell.classList.remove('clearing'); // Remove first
            void cell.offsetWidth; // Force reflow
            cell.classList.add('clearing'); // Then add
          }
        });
      });
      
      // Clear grid after animation
      setTimeout(() => {
        clearedCells.forEach(({r, c}) => {
          grid[r][c] = 0;
          const cell = gridEl.querySelector(`[data-row="${r}"][data-col="${c}"]`);
          if(cell){
            cell.classList.remove('clearing', 'filled');
          }
        });
      }, 400);
    }
    
    return linesCleared; // Return actual number of lines cleared
  }
  
  // Drag handlers
  let dragOffsetX = 0, dragOffsetY = 0;
  let previewRow = -1, previewCol = -1;
  let initialCursorX = 0, initialCursorY = 0;
  let originalPosition = null;
  let placeholder = null; // Placeholder to keep slot from collapsing
  
  function startDrag(e){
    e.preventDefault();
    const idx = parseInt(e.currentTarget.dataset.idx);
    draggedPiece = activePieces[idx];
    draggedElement = e.currentTarget;
    
    const rect = draggedElement.getBoundingClientRect();
    
    // Store original position for return animation
    originalPosition = {
      left: rect.left,
      top: rect.top
    };
    
    // Create invisible placeholder to keep slot from collapsing
    placeholder = draggedElement.cloneNode(true);
    placeholder.style.visibility = 'hidden';
    placeholder.style.pointerEvents = 'none';
    draggedElement.parentElement.appendChild(placeholder);
    
    // Center the piece under cursor for better control
    dragOffsetX = rect.width / 2;
    dragOffsetY = rect.height / 2;
    
    initialCursorX = e.clientX;
    initialCursorY = e.clientY;
    
    draggedElement.style.position = 'fixed';
    draggedElement.style.left = rect.left + 'px';
    draggedElement.style.top = rect.top + 'px';
    draggedElement.style.zIndex = '1000';
    draggedElement.style.pointerEvents = 'none';
    draggedElement.classList.add('dragging');
    
    document.addEventListener('pointermove', onDrag);
    document.addEventListener('pointerup', endDrag);
    
    onDrag(e);
  }
  
  function onDrag(e){
    if(!draggedElement) return;
    
    draggedElement.style.left = (e.clientX - dragOffsetX) + 'px';
    draggedElement.style.top = (e.clientY - dragOffsetY) + 'px';
    
    // Find the center cell of the piece shape
    const pieceRows = draggedPiece.shape.length;
    const pieceCols = draggedPiece.shape[0].length;
    const centerR = Math.floor(pieceRows / 2);
    const centerC = Math.floor(pieceCols / 2);
    
    // Check which grid cell is under the cursor (this should align with piece center)
    const cells = gridEl.querySelectorAll('.cell');
    let hoverCell = null;
    cells.forEach(cell => {
      const rect = cell.getBoundingClientRect();
      if(e.clientX >= rect.left && e.clientX <= rect.right &&
         e.clientY >= rect.top && e.clientY <= rect.bottom){
        hoverCell = cell;
      }
    });
    
    if(hoverCell){
      const hoverR = parseInt(hoverCell.dataset.row);
      const hoverC = parseInt(hoverCell.dataset.col);
      
      // Calculate top-left position of piece based on center alignment
      const topLeftR = hoverR - centerR;
      const topLeftC = hoverC - centerC;
      
      previewRow = topLeftR;
      previewCol = topLeftC;
      
      const valid = canPlace(draggedPiece, topLeftR, topLeftC);
      
      // Check if entire piece fits within grid bounds
      let entirePieceFits = true;
      for(let dr = 0; dr < draggedPiece.shape.length; dr++){
        for(let dc = 0; dc < draggedPiece.shape[dr].length; dc++){
          if(draggedPiece.shape[dr][dc] === 1){
            const gr = topLeftR + dr;
            const gc = topLeftC + dc;
            if(gr < 0 || gr >= GRID_SIZE || gc < 0 || gc >= GRID_SIZE){
              entirePieceFits = false;
              break;
            }
          }
        }
        if(!entirePieceFits) break;
      }
      
      // Collect all cells to update
      const cellsToUpdate = [];
      if(entirePieceFits){
        for(let dr = 0; dr < draggedPiece.shape.length; dr++){
          for(let dc = 0; dc < draggedPiece.shape[dr].length; dc++){
            if(draggedPiece.shape[dr][dc] === 1){
              const gr = topLeftR + dr;
              const gc = topLeftC + dc;
              const cell = gridEl.querySelector(`[data-row="${gr}"][data-col="${gc}"]`);
              if(cell){
                const isCenter = (dr === centerR && dc === centerC);
                cellsToUpdate.push({ cell, isCenter, shouldAdd: true });
              }
            }
          }
        }
      }
      
      // Clear all previews and add new ones atomically
      cells.forEach(cell => {
        const shouldUpdate = cellsToUpdate.find(c => c.cell === cell);
        if(shouldUpdate){
          // Remove old classes and add new ones immediately
          cell.classList.remove('preview', 'preview-center', 'invalid');
          if(shouldUpdate.isCenter){
            cell.classList.add(valid ? 'preview-center' : 'invalid');
          } else {
            cell.classList.add(valid ? 'preview' : 'invalid');
          }
        } else {
          // Just remove preview classes from cells not in the piece
          cell.classList.remove('preview', 'preview-center', 'invalid');
        }
      });
    } else {
      previewRow = -1;
      previewCol = -1;
    }
  }
  
  function endDrag(e){
    if(!draggedElement) return;
    
    document.removeEventListener('pointermove', onDrag);
    document.removeEventListener('pointerup', endDrag);
    
    let placed = false;
    
    // Try to place
    if(previewRow >= 0 && previewCol >= 0 && canPlace(draggedPiece, previewRow, previewCol)){
      placePiece(draggedPiece, previewRow, previewCol);
      draggedPiece.used = true;
      placed = true;
      
      // Calculate score
      const pieceSize = draggedPiece.shape.flat().filter(v => v === 1).length;
      score += pieceSize * 10;
      
      // Vibration feedback
      if(navigator.vibrate) navigator.vibrate(30);
      
      // Clear lines
      const cleared = clearLines();
      console.log('Lines cleared:', cleared, 'lastCleared will be:', cleared);
      if(cleared > 0){
        combo++;
        lastCleared = cleared;
        score += cleared * 100 * combo;
        
        // Show combo indicator with number of lines cleared
        if(cleared > 1){
          showComboIndicator(cleared);
        }
      } else {
        combo = 0;
        lastCleared = 0;
      }
      
      console.log('After update - combo:', combo, 'lastCleared:', lastCleared);
      updateScore();
      renderGrid();
      
      // Check if all pieces used
      if(activePieces.every(p => p.used)){
        addNewPieces();
      }
      
      // Check game over
      checkGameOver();
      
      // Fade out and remove placed piece with smooth effect
      draggedElement.classList.remove('dragging');
      draggedElement.style.animation = 'piecePlaced 0.3s ease-out forwards';
      
      setTimeout(() => {
        if(draggedElement) draggedElement.remove();
        if(placeholder) placeholder.remove();
        draggedElement = null;
        draggedPiece = null;
        placeholder = null;
        previewRow = -1;
        previewCol = -1;
        originalPosition = null;
      }, 300);
    } else {
      // Not placed - animate back to original position
      draggedElement.classList.remove('dragging');
      draggedElement.style.transition = 'all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)';
      
      if(originalPosition){
        draggedElement.style.left = originalPosition.left + 'px';
        draggedElement.style.top = originalPosition.top + 'px';
        draggedElement.style.opacity = '1';
      }
      
      setTimeout(() => {
        if(draggedElement) {
          // Return to static position in the pool
          draggedElement.style.position = '';
          draggedElement.style.left = '';
          draggedElement.style.top = '';
          draggedElement.style.zIndex = '';
          draggedElement.style.transition = '';
          draggedElement.style.opacity = '';
          draggedElement.style.pointerEvents = '';
        }
        if(placeholder) placeholder.remove();
        draggedElement = null;
        draggedPiece = null;
        placeholder = null;
        previewRow = -1;
        previewCol = -1;
        originalPosition = null;
        
        renderGrid();
      }, 300);
    }
  }
  
  // Check if any piece can be placed
  function checkGameOver(){
    // Check only unused pieces
    const unusedPieces = activePieces.filter(p => !p.used);
    
    // If no pieces left, don't check (new pieces will spawn)
    if(unusedPieces.length === 0) return;
    
    // Check if ANY unused piece can be placed ANYWHERE on the grid
    const anyPlaceable = unusedPieces.some(piece => {
      for(let r = 0; r < GRID_SIZE; r++){
        for(let c = 0; c < GRID_SIZE; c++){
          if(canPlace(piece, r, c)) return true;
        }
      }
      return false;
    });
    
    // If no piece can be placed, game over
    if(!anyPlaceable){
      endGame();
    }
  }
  
  // Show combo indicator
  function showComboIndicator(linesCleared){
    const indicator = document.getElementById('comboIndicator');
    indicator.textContent = `COMBO √ó${linesCleared}! üî•`;
    indicator.classList.remove('show');
    // Force reflow
    void indicator.offsetWidth;
    indicator.classList.add('show');
    
    setTimeout(() => {
      indicator.classList.remove('show');
    }, 1300);
  }
  
  // Update score display
  function updateScore(){
    document.getElementById('score').textContent = score;
    document.getElementById('combo').textContent = lastCleared;
    if(score > best){
      best = score;
      localStorage.setItem('bb_best', best);
      document.getElementById('best').textContent = best;
    }
  }
  
  // Game over
  function endGame(){
    document.getElementById('finalScore').textContent = score;
    document.getElementById('finalBest').textContent = best;
    document.getElementById('gameOver').classList.add('show');
  }
  
  // Restart game
  document.getElementById('restart').addEventListener('click', () => {
    grid.forEach(row => row.fill(0));
    score = 0;
    combo = 0;
    lastCleared = 0;
    updateScore();
    renderGrid();
    addNewPieces();
    document.getElementById('gameOver').classList.remove('show');
  });
  
  // Initialize
  document.getElementById('best').textContent = best;
  spawnPieces();
  renderGrid();
  </script>
</body>
</html>
